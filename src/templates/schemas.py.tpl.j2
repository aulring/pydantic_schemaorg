from __future__ import annotations
import time
from datetime import datetime, date
from pydantic import BaseModel

import re
from typing import Optional

import networkx as nx
from pydantic import *
from typing import *

import pickle



INITIALIZED_MODELS = {}

class DependencyDict(dict):
    G = nx.DiGraph()
    failure = {}
    
    @staticmethod
    def get_model_from_str(field: str):
        print(field)
        m = re.search(r"\(([A-Z'a-z0-9_]+)\)", field)
        return m.group(1).replace("'", "")
    
    
    def resolve_dependency_graph(self):
        if not LOOKUP.G.is_directed():
            raise ValueError("Can only resolve directed dependencies.")
        for n in nx.topological_sort(self.G):
            print(f"resolving dependency {n}")
            model = str(n)
            if model in self.failure:
                fields = self.failure[model]
                self.__setitem__(model, fields)
            else:
                if not model in INITIALIZED_MODELS:
                    print(f"unknown error. model: {model} is not in initialized models or failures!")
        
            
    def __setitem__(self, *args, **kwargs):
        failed = False
        model, fields =  args
        for field_key, types in fields.items():
            if  isinstance(types[0], str):
                if not "dynamic_creation" in types[0]:
                    continue
                try:
                    initialized = eval(types[0])
                    print(f"initialized model: {model}")
                except KeyError as e:
                    print(f"cannont initialize {model} at this time. Will create dependency graph and execute later.")
                    self.G.add_edge(model, self.get_model_from_str(types[0]))
                    failed = True
                    if model in types[0]:
                        print("self reference detected! dropping field!")
                        fields[field_key] = (Any, None)

        if failed:
            self.failure[model] = fields
        else:
            super().__setitem__(*args, **kwargs)
        
        

LOOKUP = DependencyDict()


def dynamic_creation(model: str):
    if model not in INITIALIZED_MODELS:
        fields = LOOKUP[model]
        dynamic_creation = create_model(model, __base__=BaseModel, **fields)
        INITIALIZED_MODELS[model] = dynamic_creation
        return dynamic_creation
    else:
        return INITIALIZED_MODELS[model]


{% for model in models %}
{{model.to_lookup()}}
{%- endfor%}


pickle.dump(LOOKUP.G, open('graph.pickle', 'wb'))
LOOKUP.resolve_dependency_graph()


{%for model in models %}
{{model.valid_name}} = dynamic_creation("{{model.valid_name}}")
{%- endfor -%}
